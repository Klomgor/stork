package agent

import (
	"crypto/tls"
	"crypto/x509"
	"net"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"isc.org/stork/pki"
	storkutil "isc.org/stork/util"
)

type CertStore struct {
	// Paths pointing to agent's key and cert, and CA cert from server,
	// and agent token generated by agent.
	keyPEMPath  string
	certPEMPath string
	rootCAPAth  string
	tokenPath   string
}

func NewCertStore() *CertStore {
	return &CertStore{
		keyPEMPath:  "/var/lib/stork-agent/certs/key.pem",
		certPEMPath: "/var/lib/stork-agent/certs/cert.pem",
		rootCAPAth:  "/var/lib/stork-agent/certs/ca.pem",
		tokenPath:   "/var/lib/stork-agent/tokens/agent-token.txt",
	}
}

func isPathExist(path string) bool {
	_, err := os.Stat(path)
	return errors.Is(err, os.ErrNotExist)
}

func overrideFile(path string, content []byte) error {
	if isPathExist(path) {
		if err := os.Remove(path); err != nil {
			return errors.Wrapf(err, "cannot remove old agent file: %s", path)
		}
	}

	directory := filepath.Dir(path)
	if !isPathExist(directory) {
		if err := os.MkdirAll(directory, 0o700); err != nil {
			return errors.Wrapf(err, "cannot create a directory for Stork files: %s", directory)
		}
	}

	if err := os.WriteFile(path, content, 0o600); err != nil {
		return errors.Wrapf(err, "cannot write file: %s", path)
	}
	return nil
}

func removeIfExist(path string) error {
	if !isPathExist(path) {
		return nil
	}

	err := os.Remove(path)
	if err != nil {
		return errors.Wrapf(err, "cannot remove '%s'", path)
	}
	return nil
}

func isValidCert(path string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return errors.Wrapf(err, "cannot read the '%s' cert file", path)
	}
	_, err = pki.ParseCert(content)
	return err
}

func isValidPrivateKeyCert(path string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return errors.Wrapf(err, "cannot read the '%s' cert file", path)
	}
	_, err = pki.ParsePrivateKey(content)
	return err
}

// Parse provided address and return either an IP address as a one
// element list or a DNS name as one element list. The arrays are
// returned as then it is easy to pass these returned elements to the
// functions that generates CSR (Certificate Signing Request).
func resolveAddress(address string) ([]net.IP, []string) {
	ipAddress := net.ParseIP(address)
	if ipAddress != nil {
		return []net.IP{ipAddress}, []string{}
	}
	return []net.IP{}, []string{address}
}

func (s *CertStore) ReadKeyPEM() ([]byte, error) {
	keyPEM, err := os.ReadFile(s.keyPEMPath)
	if err != nil {
		err = errors.Wrapf(err, "could not load key PEM file: %s", s.keyPEMPath)
		return nil, err
	}
	return keyPEM, nil
}

func (s *CertStore) ReadRootCAPEM() ([]byte, error) {
	ca, err := os.ReadFile(s.rootCAPAth)
	if err != nil {
		err = errors.Wrapf(err, "could not read CA certificate: %s", s.rootCAPAth)
		return nil, err
	}
	return ca, nil
}

func (s *CertStore) ReadCertPEM() ([]byte, error) {
	certPEM, err := os.ReadFile(s.certPEMPath)
	if err != nil {
		err = errors.Wrapf(err, "could not load cert PEM file: %s", s.certPEMPath)
		return nil, err
	}
	return certPEM, nil
}

func (s *CertStore) ReadToken() ([]byte, error) {
	token, err := os.ReadFile(s.tokenPath)
	if err != nil {
		err = errors.Wrapf(err, "could not load token file: %s", s.tokenPath)
	}
	return token, err
}

func (s *CertStore) GetRootCA() (*x509.CertPool, error) {
	certPool := x509.NewCertPool()
	ca, err := s.ReadRootCAPEM()
	if err != nil {
		return nil, err
	}

	// append the client certificates from the CA
	if ok := certPool.AppendCertsFromPEM(ca); !ok {
		err = errors.New("failed to append client root CA certificate")
		return nil, err
	}
	return certPool, nil
}

func (s *CertStore) GetTLSCert() (*tls.Certificate, error) {
	keyPEM, err := s.ReadKeyPEM()
	if err != nil {
		return nil, err
	}
	certPEM, err := s.ReadCertPEM()
	if err != nil {
		return nil, err
	}
	certificate, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		err = errors.Wrapf(err, "could not setup TLS key pair")
		return nil, err
	}
	return &certificate, nil
}

func (s *CertStore) CreateKey() error {
	keyPEM, err := pki.GenKey()
	if err != nil {
		return err
	}
	err = overrideFile(s.keyPEMPath, keyPEM)
	if err != nil {
		return errors.Wrapf(err, "cannot write key file: %s", keyPEM)
	}

	// Invalidate cert, root CA and token.
	if err = removeIfExist(s.certPEMPath); err != nil {
		return err
	}
	if err = removeIfExist(s.rootCAPAth); err != nil {
		return err
	}
	if err = removeIfExist(s.tokenPath); err != nil {
		return err
	}
	return nil
}

func (s *CertStore) GenerateCSR(agentAddress string) (csrPEM []byte, fingerprint [32]byte, err error) {
	agentIPs, agentNames := resolveAddr(agentAddress)
	keyPEM, err := s.ReadKeyPEM()
	if err != nil {
		return
	}

	csrPEM, fingerprint, err = pki.GenCSRUsingKey("agent", agentNames, agentIPs, keyPEM)
	if err != nil {
		err = errors.WithMessagef(err, "cannot generate CSR and private key for '%s' address", agentAddress)
		return
	}

	return
}

func (s *CertStore) WriteFingerprintAsToken(fingerprint [32]byte) error {
	fingerprintStr := storkutil.BytesToHex(fingerprint[:])
	return overrideFile(s.tokenPath, []byte(fingerprintStr))
}

func (s *CertStore) WriteRootCAPEM(rootCAPEM []byte) error {
	_, err := pki.ParseCert(rootCAPEM)
	if err != nil {
		return errors.WithMessage(err, "invalid Root CA file")
	}
	return overrideFile(s.rootCAPAth, rootCAPEM)
}

func (s *CertStore) WriteCertPEM(certPEM []byte) error {
	_, err := pki.ParseCert(certPEM)
	if err != nil {
		return errors.WithMessage(err, "invalid cert file")
	}
	return overrideFile(s.rootCAPAth, certPEM)
}

func (s *CertStore) IsValid() error {
	var validationErrors []error
	if err := isValidCert(s.certPEMPath); err != nil {
		validationErrors = append(validationErrors, err)
	}
	if err := isValidCert(s.rootCAPAth); err != nil {
		validationErrors = append(validationErrors, err)
	}
	if err := isValidPrivateKeyCert(s.keyPEMPath); err != nil {
		validationErrors = append(validationErrors, err)
	}
	if content, err := os.ReadFile(s.tokenPath); err != nil || len(content) == 0 {
		if err == nil {
			err = errors.Errorf("empty token file: %s", s.tokenPath)
		}
		validationErrors = append(validationErrors, err)
	}
	return storkutil.CombineErrors("cert store is not valid", validationErrors)
}

func (s *CertStore) IsEmpty() bool {
	return !isPathExist(s.keyPEMPath) &&
		!isPathExist(s.certPEMPath) &&
		!isPathExist(s.rootCAPAth) &&
		!isPathExist(s.tokenPath)
}
